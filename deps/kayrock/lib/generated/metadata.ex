defmodule(Kayrock.Metadata) do
  @api :metadata
  @moduledoc "Kayrock-generated module for the Kafka `#{@api}` API\n"
  _ = " THIS CODE IS GENERATED BY KAYROCK"

  (
    @vmin 0
    @vmax 5
  )

  defmodule(V0.Request) do
    @vsn 0
    @api :metadata
    @schema topics: {:array, :string}
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(topics: [], correlation_id: nil, client_id: nil)
    import(Elixir.Kayrock.Serialize)
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            topics: [nil | binary()],
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      0
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V0.Response.t(), binary})
    def(response_deserializer) do
      &V0.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [topics: {:array, :string}]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def(serialize(%V0.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [serialize_array(:string, Map.fetch!(struct, :topics))]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V0.Request) do
    def(serialize(%V0.Request{} = struct)) do
      try do
        V0.Request.serialize(struct)
      rescue
        e ->
          reraise(Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__)
      end
    end

    def(api_vsn(%V0.Request{})) do
      V0.Request.api_vsn()
    end

    def(response_deserializer(%V0.Request{})) do
      V0.Request.response_deserializer()
    end
  end

  defmodule(V1.Request) do
    @vsn 1
    @api :metadata
    @schema topics: {:array, :string}
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(topics: [], correlation_id: nil, client_id: nil)
    import(Elixir.Kayrock.Serialize)
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            topics: [nil | binary()],
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      1
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V1.Response.t(), binary})
    def(response_deserializer) do
      &V1.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [topics: {:array, :string}]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def(serialize(%V1.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [serialize_array(:string, Map.fetch!(struct, :topics))]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V1.Request) do
    def(serialize(%V1.Request{} = struct)) do
      try do
        V1.Request.serialize(struct)
      rescue
        e ->
          reraise(Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__)
      end
    end

    def(api_vsn(%V1.Request{})) do
      V1.Request.api_vsn()
    end

    def(response_deserializer(%V1.Request{})) do
      V1.Request.response_deserializer()
    end
  end

  defmodule(V2.Request) do
    @vsn 2
    @api :metadata
    @schema topics: {:array, :string}
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(topics: [], correlation_id: nil, client_id: nil)
    import(Elixir.Kayrock.Serialize)
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            topics: [nil | binary()],
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      2
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V2.Response.t(), binary})
    def(response_deserializer) do
      &V2.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [topics: {:array, :string}]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def(serialize(%V2.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [serialize_array(:string, Map.fetch!(struct, :topics))]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V2.Request) do
    def(serialize(%V2.Request{} = struct)) do
      try do
        V2.Request.serialize(struct)
      rescue
        e ->
          reraise(Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__)
      end
    end

    def(api_vsn(%V2.Request{})) do
      V2.Request.api_vsn()
    end

    def(response_deserializer(%V2.Request{})) do
      V2.Request.response_deserializer()
    end
  end

  defmodule(V3.Request) do
    @vsn 3
    @api :metadata
    @schema topics: {:array, :string}
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(topics: [], correlation_id: nil, client_id: nil)
    import(Elixir.Kayrock.Serialize)
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            topics: [nil | binary()],
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      3
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V3.Response.t(), binary})
    def(response_deserializer) do
      &V3.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [topics: {:array, :string}]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def(serialize(%V3.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [serialize_array(:string, Map.fetch!(struct, :topics))]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V3.Request) do
    def(serialize(%V3.Request{} = struct)) do
      try do
        V3.Request.serialize(struct)
      rescue
        e ->
          reraise(Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__)
      end
    end

    def(api_vsn(%V3.Request{})) do
      V3.Request.api_vsn()
    end

    def(response_deserializer(%V3.Request{})) do
      V3.Request.response_deserializer()
    end
  end

  defmodule(V4.Request) do
    @vsn 4
    @api :metadata
    @schema topics: {:array, :string}, allow_auto_topic_creation: :boolean
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(topics: [], allow_auto_topic_creation: nil, correlation_id: nil, client_id: nil)
    import(Elixir.Kayrock.Serialize)
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            topics: [nil | binary()],
            allow_auto_topic_creation: nil | integer(),
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      4
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V4.Response.t(), binary})
    def(response_deserializer) do
      &V4.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [topics: {:array, :string}, allow_auto_topic_creation: :boolean]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def(serialize(%V4.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [
          serialize_array(:string, Map.fetch!(struct, :topics)),
          serialize(:boolean, Map.fetch!(struct, :allow_auto_topic_creation))
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V4.Request) do
    def(serialize(%V4.Request{} = struct)) do
      try do
        V4.Request.serialize(struct)
      rescue
        e ->
          reraise(Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__)
      end
    end

    def(api_vsn(%V4.Request{})) do
      V4.Request.api_vsn()
    end

    def(response_deserializer(%V4.Request{})) do
      V4.Request.response_deserializer()
    end
  end

  defmodule(V5.Request) do
    @vsn 5
    @api :metadata
    @schema topics: {:array, :string}, allow_auto_topic_creation: :boolean
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(topics: [], allow_auto_topic_creation: nil, correlation_id: nil, client_id: nil)
    import(Elixir.Kayrock.Serialize)
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            topics: [nil | binary()],
            allow_auto_topic_creation: nil | integer(),
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      5
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V5.Response.t(), binary})
    def(response_deserializer) do
      &V5.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [topics: {:array, :string}, allow_auto_topic_creation: :boolean]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def(serialize(%V5.Request{} = struct)) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [
          serialize_array(:string, Map.fetch!(struct, :topics)),
          serialize(:boolean, Map.fetch!(struct, :allow_auto_topic_creation))
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V5.Request) do
    def(serialize(%V5.Request{} = struct)) do
      try do
        V5.Request.serialize(struct)
      rescue
        e ->
          reraise(Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__)
      end
    end

    def(api_vsn(%V5.Request{})) do
      V5.Request.api_vsn()
    end

    def(response_deserializer(%V5.Request{})) do
      V5.Request.response_deserializer()
    end
  end

  (
    @doc "Returns a request struct for this API with the given version"
    @spec get_request_struct(integer) :: request_t
  )

  def(get_request_struct(0)) do
    %V0.Request{}
  end

  def(get_request_struct(1)) do
    %V1.Request{}
  end

  def(get_request_struct(2)) do
    %V2.Request{}
  end

  def(get_request_struct(3)) do
    %V3.Request{}
  end

  def(get_request_struct(4)) do
    %V4.Request{}
  end

  def(get_request_struct(5)) do
    %V5.Request{}
  end

  defmodule(V0.Response) do
    @vsn 0
    @api :metadata
    @schema brokers: {:array, [node_id: :int32, host: :string, port: :int32]},
            topic_metadata:
              {:array,
               [
                 error_code: :int16,
                 topic: :string,
                 partition_metadata:
                   {:array,
                    [
                      error_code: :int16,
                      partition: :int32,
                      leader: :int32,
                      replicas: {:array, :int32},
                      isr: {:array, :int32}
                    ]}
               ]}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(brokers: [], topic_metadata: [], correlation_id: nil)
    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            brokers: [%{node_id: nil | integer(), host: nil | binary(), port: nil | integer()}],
            topic_metadata: [
              %{
                error_code: nil | integer(),
                topic: nil | binary(),
                partition_metadata: [
                  %{
                    error_code: nil | integer(),
                    partition: nil | integer(),
                    leader: nil | integer(),
                    replicas: [nil | integer()],
                    isr: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import(Elixir.Kayrock.Deserialize)
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      0
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [
        brokers: {:array, [node_id: :int32, host: :string, port: :int32]},
        topic_metadata:
          {:array,
           [
             error_code: :int16,
             topic: :string,
             partition_metadata:
               {:array,
                [
                  error_code: :int16,
                  partition: :int32,
                  leader: :int32,
                  replicas: {:array, :int32},
                  isr: {:array, :int32}
                ]}
           ]}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data
      deserialize_field(:root, :brokers, %__MODULE__{correlation_id: correlation_id}, rest)
    end

    defp(deserialize_field(:brokers, :node_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp(deserialize_field(:brokers, :host, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp(deserialize_field(:brokers, :port, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, nil, Map.put(acc, :port, val), rest)
    end

    defp(deserialize_field(:root, :brokers, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :topic_metadata, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(:topic_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topic_metadata, :topic, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topic_metadata, :partition_metadata, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_metadata, :partition, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :leader, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :leader, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :replicas, Map.put(acc, :leader, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :replicas, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partition_metadata,
        :isr,
        Map.put(acc, :replicas, Enum.reverse(val)),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :isr, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)
      deserialize_field(:partition_metadata, nil, Map.put(acc, :isr, Enum.reverse(val)), rest)
    end

    defp(deserialize_field(:topic_metadata, :partition_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :topic_metadata,
        nil,
        Map.put(acc, :partition_metadata, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :topic_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topic_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topic_metadata, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V1.Response) do
    @vsn 1
    @api :metadata
    @schema brokers:
              {:array, [node_id: :int32, host: :string, port: :int32, rack: :nullable_string]},
            controller_id: :int32,
            topic_metadata:
              {:array,
               [
                 error_code: :int16,
                 topic: :string,
                 is_internal: :boolean,
                 partition_metadata:
                   {:array,
                    [
                      error_code: :int16,
                      partition: :int32,
                      leader: :int32,
                      replicas: {:array, :int32},
                      isr: {:array, :int32}
                    ]}
               ]}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct(brokers: [], controller_id: nil, topic_metadata: [], correlation_id: nil)
    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            controller_id: nil | integer(),
            topic_metadata: [
              %{
                error_code: nil | integer(),
                topic: nil | binary(),
                is_internal: nil | integer(),
                partition_metadata: [
                  %{
                    error_code: nil | integer(),
                    partition: nil | integer(),
                    leader: nil | integer(),
                    replicas: [nil | integer()],
                    isr: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import(Elixir.Kayrock.Deserialize)
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [
        brokers: {:array, [node_id: :int32, host: :string, port: :int32, rack: :nullable_string]},
        controller_id: :int32,
        topic_metadata:
          {:array,
           [
             error_code: :int16,
             topic: :string,
             is_internal: :boolean,
             partition_metadata:
               {:array,
                [
                  error_code: :int16,
                  partition: :int32,
                  leader: :int32,
                  replicas: {:array, :int32},
                  isr: {:array, :int32}
                ]}
           ]}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data
      deserialize_field(:root, :brokers, %__MODULE__{correlation_id: correlation_id}, rest)
    end

    defp(deserialize_field(:brokers, :node_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp(deserialize_field(:brokers, :host, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp(deserialize_field(:brokers, :port, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp(deserialize_field(:brokers, :rack, acc, data)) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp(deserialize_field(:root, :brokers, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :controller_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(:root, :controller_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topic_metadata, Map.put(acc, :controller_id, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topic_metadata, :topic, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topic_metadata, :is_internal, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :is_internal, acc, data)) do
      {val, rest} = deserialize(:boolean, data)

      deserialize_field(
        :topic_metadata,
        :partition_metadata,
        Map.put(acc, :is_internal, val),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_metadata, :partition, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :leader, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :leader, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :replicas, Map.put(acc, :leader, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :replicas, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partition_metadata,
        :isr,
        Map.put(acc, :replicas, Enum.reverse(val)),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :isr, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)
      deserialize_field(:partition_metadata, nil, Map.put(acc, :isr, Enum.reverse(val)), rest)
    end

    defp(deserialize_field(:topic_metadata, :partition_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :topic_metadata,
        nil,
        Map.put(acc, :partition_metadata, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :topic_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topic_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topic_metadata, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V2.Response) do
    @vsn 2
    @api :metadata
    @schema brokers:
              {:array, [node_id: :int32, host: :string, port: :int32, rack: :nullable_string]},
            cluster_id: :nullable_string,
            controller_id: :int32,
            topic_metadata:
              {:array,
               [
                 error_code: :int16,
                 topic: :string,
                 is_internal: :boolean,
                 partition_metadata:
                   {:array,
                    [
                      error_code: :int16,
                      partition: :int32,
                      leader: :int32,
                      replicas: {:array, :int32},
                      isr: {:array, :int32}
                    ]}
               ]}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      brokers: [],
      cluster_id: nil,
      controller_id: nil,
      topic_metadata: [],
      correlation_id: nil
    )

    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topic_metadata: [
              %{
                error_code: nil | integer(),
                topic: nil | binary(),
                is_internal: nil | integer(),
                partition_metadata: [
                  %{
                    error_code: nil | integer(),
                    partition: nil | integer(),
                    leader: nil | integer(),
                    replicas: [nil | integer()],
                    isr: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import(Elixir.Kayrock.Deserialize)
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      2
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [
        brokers: {:array, [node_id: :int32, host: :string, port: :int32, rack: :nullable_string]},
        cluster_id: :nullable_string,
        controller_id: :int32,
        topic_metadata:
          {:array,
           [
             error_code: :int16,
             topic: :string,
             is_internal: :boolean,
             partition_metadata:
               {:array,
                [
                  error_code: :int16,
                  partition: :int32,
                  leader: :int32,
                  replicas: {:array, :int32},
                  isr: {:array, :int32}
                ]}
           ]}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data
      deserialize_field(:root, :brokers, %__MODULE__{correlation_id: correlation_id}, rest)
    end

    defp(deserialize_field(:brokers, :node_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp(deserialize_field(:brokers, :host, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp(deserialize_field(:brokers, :port, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp(deserialize_field(:brokers, :rack, acc, data)) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp(deserialize_field(:root, :brokers, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(:root, :cluster_id, acc, data)) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp(deserialize_field(:root, :controller_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topic_metadata, Map.put(acc, :controller_id, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topic_metadata, :topic, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topic_metadata, :is_internal, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :is_internal, acc, data)) do
      {val, rest} = deserialize(:boolean, data)

      deserialize_field(
        :topic_metadata,
        :partition_metadata,
        Map.put(acc, :is_internal, val),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_metadata, :partition, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :leader, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :leader, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :replicas, Map.put(acc, :leader, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :replicas, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partition_metadata,
        :isr,
        Map.put(acc, :replicas, Enum.reverse(val)),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :isr, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)
      deserialize_field(:partition_metadata, nil, Map.put(acc, :isr, Enum.reverse(val)), rest)
    end

    defp(deserialize_field(:topic_metadata, :partition_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :topic_metadata,
        nil,
        Map.put(acc, :partition_metadata, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :topic_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topic_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topic_metadata, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V3.Response) do
    @vsn 3
    @api :metadata
    @schema throttle_time_ms: :int32,
            brokers:
              {:array, [node_id: :int32, host: :string, port: :int32, rack: :nullable_string]},
            cluster_id: :nullable_string,
            controller_id: :int32,
            topic_metadata:
              {:array,
               [
                 error_code: :int16,
                 topic: :string,
                 is_internal: :boolean,
                 partition_metadata:
                   {:array,
                    [
                      error_code: :int16,
                      partition: :int32,
                      leader: :int32,
                      replicas: {:array, :int32},
                      isr: {:array, :int32}
                    ]}
               ]}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      throttle_time_ms: nil,
      brokers: [],
      cluster_id: nil,
      controller_id: nil,
      topic_metadata: [],
      correlation_id: nil
    )

    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            throttle_time_ms: nil | integer(),
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topic_metadata: [
              %{
                error_code: nil | integer(),
                topic: nil | binary(),
                is_internal: nil | integer(),
                partition_metadata: [
                  %{
                    error_code: nil | integer(),
                    partition: nil | integer(),
                    leader: nil | integer(),
                    replicas: [nil | integer()],
                    isr: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import(Elixir.Kayrock.Deserialize)
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      3
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [
        throttle_time_ms: :int32,
        brokers: {:array, [node_id: :int32, host: :string, port: :int32, rack: :nullable_string]},
        cluster_id: :nullable_string,
        controller_id: :int32,
        topic_metadata:
          {:array,
           [
             error_code: :int16,
             topic: :string,
             is_internal: :boolean,
             partition_metadata:
               {:array,
                [
                  error_code: :int16,
                  partition: :int32,
                  leader: :int32,
                  replicas: {:array, :int32},
                  isr: {:array, :int32}
                ]}
           ]}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp(deserialize_field(:root, :throttle_time_ms, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :brokers, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp(deserialize_field(:brokers, :node_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp(deserialize_field(:brokers, :host, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp(deserialize_field(:brokers, :port, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp(deserialize_field(:brokers, :rack, acc, data)) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp(deserialize_field(:root, :brokers, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(:root, :cluster_id, acc, data)) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp(deserialize_field(:root, :controller_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topic_metadata, Map.put(acc, :controller_id, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topic_metadata, :topic, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topic_metadata, :is_internal, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :is_internal, acc, data)) do
      {val, rest} = deserialize(:boolean, data)

      deserialize_field(
        :topic_metadata,
        :partition_metadata,
        Map.put(acc, :is_internal, val),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_metadata, :partition, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :leader, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :leader, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :replicas, Map.put(acc, :leader, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :replicas, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partition_metadata,
        :isr,
        Map.put(acc, :replicas, Enum.reverse(val)),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :isr, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)
      deserialize_field(:partition_metadata, nil, Map.put(acc, :isr, Enum.reverse(val)), rest)
    end

    defp(deserialize_field(:topic_metadata, :partition_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :topic_metadata,
        nil,
        Map.put(acc, :partition_metadata, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :topic_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topic_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topic_metadata, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V4.Response) do
    @vsn 4
    @api :metadata
    @schema throttle_time_ms: :int32,
            brokers:
              {:array, [node_id: :int32, host: :string, port: :int32, rack: :nullable_string]},
            cluster_id: :nullable_string,
            controller_id: :int32,
            topic_metadata:
              {:array,
               [
                 error_code: :int16,
                 topic: :string,
                 is_internal: :boolean,
                 partition_metadata:
                   {:array,
                    [
                      error_code: :int16,
                      partition: :int32,
                      leader: :int32,
                      replicas: {:array, :int32},
                      isr: {:array, :int32}
                    ]}
               ]}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      throttle_time_ms: nil,
      brokers: [],
      cluster_id: nil,
      controller_id: nil,
      topic_metadata: [],
      correlation_id: nil
    )

    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            throttle_time_ms: nil | integer(),
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topic_metadata: [
              %{
                error_code: nil | integer(),
                topic: nil | binary(),
                is_internal: nil | integer(),
                partition_metadata: [
                  %{
                    error_code: nil | integer(),
                    partition: nil | integer(),
                    leader: nil | integer(),
                    replicas: [nil | integer()],
                    isr: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import(Elixir.Kayrock.Deserialize)
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      4
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [
        throttle_time_ms: :int32,
        brokers: {:array, [node_id: :int32, host: :string, port: :int32, rack: :nullable_string]},
        cluster_id: :nullable_string,
        controller_id: :int32,
        topic_metadata:
          {:array,
           [
             error_code: :int16,
             topic: :string,
             is_internal: :boolean,
             partition_metadata:
               {:array,
                [
                  error_code: :int16,
                  partition: :int32,
                  leader: :int32,
                  replicas: {:array, :int32},
                  isr: {:array, :int32}
                ]}
           ]}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp(deserialize_field(:root, :throttle_time_ms, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :brokers, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp(deserialize_field(:brokers, :node_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp(deserialize_field(:brokers, :host, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp(deserialize_field(:brokers, :port, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp(deserialize_field(:brokers, :rack, acc, data)) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp(deserialize_field(:root, :brokers, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(:root, :cluster_id, acc, data)) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp(deserialize_field(:root, :controller_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topic_metadata, Map.put(acc, :controller_id, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topic_metadata, :topic, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topic_metadata, :is_internal, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :is_internal, acc, data)) do
      {val, rest} = deserialize(:boolean, data)

      deserialize_field(
        :topic_metadata,
        :partition_metadata,
        Map.put(acc, :is_internal, val),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_metadata, :partition, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :leader, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :leader, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :replicas, Map.put(acc, :leader, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :replicas, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partition_metadata,
        :isr,
        Map.put(acc, :replicas, Enum.reverse(val)),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :isr, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)
      deserialize_field(:partition_metadata, nil, Map.put(acc, :isr, Enum.reverse(val)), rest)
    end

    defp(deserialize_field(:topic_metadata, :partition_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :topic_metadata,
        nil,
        Map.put(acc, :partition_metadata, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :topic_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topic_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topic_metadata, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  defmodule(V5.Response) do
    @vsn 5
    @api :metadata
    @schema throttle_time_ms: :int32,
            brokers:
              {:array, [node_id: :int32, host: :string, port: :int32, rack: :nullable_string]},
            cluster_id: :nullable_string,
            controller_id: :int32,
            topic_metadata:
              {:array,
               [
                 error_code: :int16,
                 topic: :string,
                 is_internal: :boolean,
                 partition_metadata:
                   {:array,
                    [
                      error_code: :int16,
                      partition: :int32,
                      leader: :int32,
                      replicas: {:array, :int32},
                      isr: {:array, :int32},
                      offline_replicas: {:array, :int32}
                    ]}
               ]}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API\nmessages\n\nThe schema of this API is\n```\n#{
                 inspect(@schema, pretty: true)
               }\n```\n"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct(
      throttle_time_ms: nil,
      brokers: [],
      cluster_id: nil,
      controller_id: nil,
      topic_metadata: [],
      correlation_id: nil
    )

    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}\n"
    @type t :: %__MODULE__{
            throttle_time_ms: nil | integer(),
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topic_metadata: [
              %{
                error_code: nil | integer(),
                topic: nil | binary(),
                is_internal: nil | integer(),
                partition_metadata: [
                  %{
                    error_code: nil | integer(),
                    partition: nil | integer(),
                    leader: nil | integer(),
                    replicas: [nil | integer()],
                    isr: [nil | integer()],
                    offline_replicas: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import(Elixir.Kayrock.Deserialize)
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def(api_key) do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def(api_vsn) do
      5
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def(schema) do
      [
        throttle_time_ms: :int32,
        brokers: {:array, [node_id: :int32, host: :string, port: :int32, rack: :nullable_string]},
        cluster_id: :nullable_string,
        controller_id: :int32,
        topic_metadata:
          {:array,
           [
             error_code: :int16,
             topic: :string,
             is_internal: :boolean,
             partition_metadata:
               {:array,
                [
                  error_code: :int16,
                  partition: :int32,
                  leader: :int32,
                  replicas: {:array, :int32},
                  isr: {:array, :int32},
                  offline_replicas: {:array, :int32}
                ]}
           ]}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def(deserialize(data)) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp(deserialize_field(:root, :throttle_time_ms, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :brokers, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp(deserialize_field(:brokers, :node_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp(deserialize_field(:brokers, :host, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp(deserialize_field(:brokers, :port, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp(deserialize_field(:brokers, :rack, acc, data)) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp(deserialize_field(:root, :brokers, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(:root, :cluster_id, acc, data)) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp(deserialize_field(:root, :controller_id, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topic_metadata, Map.put(acc, :controller_id, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topic_metadata, :topic, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :topic, acc, data)) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topic_metadata, :is_internal, Map.put(acc, :topic, val), rest)
    end

    defp(deserialize_field(:topic_metadata, :is_internal, acc, data)) do
      {val, rest} = deserialize(:boolean, data)

      deserialize_field(
        :topic_metadata,
        :partition_metadata,
        Map.put(acc, :is_internal, val),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :error_code, acc, data)) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partition_metadata, :partition, Map.put(acc, :error_code, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :partition, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :leader, Map.put(acc, :partition, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :leader, acc, data)) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partition_metadata, :replicas, Map.put(acc, :leader, val), rest)
    end

    defp(deserialize_field(:partition_metadata, :replicas, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partition_metadata,
        :isr,
        Map.put(acc, :replicas, Enum.reverse(val)),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :isr, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partition_metadata,
        :offline_replicas,
        Map.put(acc, :isr, Enum.reverse(val)),
        rest
      )
    end

    defp(deserialize_field(:partition_metadata, :offline_replicas, acc, data)) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partition_metadata,
        nil,
        Map.put(acc, :offline_replicas, Enum.reverse(val)),
        rest
      )
    end

    defp(deserialize_field(:topic_metadata, :partition_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partition_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :topic_metadata,
        nil,
        Map.put(acc, :partition_metadata, Enum.reverse(vals)),
        rest
      )
    end

    defp(deserialize_field(:root, :topic_metadata, acc, data)) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if(num_elements > 0) do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topic_metadata, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topic_metadata, Enum.reverse(vals)), rest)
    end

    defp(deserialize_field(_, nil, acc, rest)) do
      {acc, rest}
    end
  end

  (
    @doc "Deserializes raw wire data for this API with the given version"
    @spec deserialize(integer, binary) :: {response_t, binary}
  )

  def(deserialize(0, data)) do
    V0.Response.deserialize(data)
  end

  def(deserialize(1, data)) do
    V1.Response.deserialize(data)
  end

  def(deserialize(2, data)) do
    V2.Response.deserialize(data)
  end

  def(deserialize(3, data)) do
    V3.Response.deserialize(data)
  end

  def(deserialize(4, data)) do
    V4.Response.deserialize(data)
  end

  def(deserialize(5, data)) do
    V5.Response.deserialize(data)
  end

  (
    @typedoc "Union type for all request structs for this API"
    @type request_t ::
            Kayrock.Metadata.V5.Request.t()
            | Kayrock.Metadata.V4.Request.t()
            | Kayrock.Metadata.V3.Request.t()
            | Kayrock.Metadata.V2.Request.t()
            | Kayrock.Metadata.V1.Request.t()
            | Kayrock.Metadata.V0.Request.t()
  )

  (
    @typedoc "Union type for all response structs for this API"
    @type response_t ::
            Kayrock.Metadata.V5.Response.t()
            | Kayrock.Metadata.V4.Response.t()
            | Kayrock.Metadata.V3.Response.t()
            | Kayrock.Metadata.V2.Response.t()
            | Kayrock.Metadata.V1.Response.t()
            | Kayrock.Metadata.V0.Response.t()
  )

  (
    @doc "Returns the minimum version of this API supported by Kayrock (#{@vmin})"
    @spec min_vsn :: integer
    def(min_vsn) do
      0
    end
  )

  (
    @doc "Returns the maximum version of this API supported by Kayrock (#{@vmax})"
    @spec max_vsn :: integer
    def(max_vsn) do
      5
    end
  )
end
